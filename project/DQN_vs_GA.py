{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "017382af-96a2-460d-b558-e3f12a1a3515",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "100%|██████████| 600/600 [16:17<00:00,  1.63s/it]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Complete\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 640x480 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Execution time: 977.4663231372833 seconds\n"
     ]
    }
   ],
   "source": [
    "import gymnasium as gym\n",
    "import math\n",
    "import random\n",
    "import matplotlib\n",
    "import time\n",
    "import matplotlib.pyplot as plt\n",
    "from collections import namedtuple, deque\n",
    "from itertools import count\n",
    "\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "import torch.nn.functional as F\n",
    "from tqdm import tqdm\n",
    "\n",
    "start_time = time.time()  # Start time\n",
    "\n",
    "# Your code here\n",
    "\n",
    "class DQN(nn.Module):\n",
    "    def __init__(self, n_observations, n_actions):\n",
    "        super(DQN, self).__init__()\n",
    "        self.layer1 = nn.Linear(n_observations, 128)\n",
    "        self.layer2 = nn.Linear(128, 128)\n",
    "        self.layer3 = nn.Linear(128, n_actions)\n",
    "\n",
    "    # Called with either one element to determine next action, or a batch\n",
    "    # during optimization. Returns tensor([[left0exp,right0exp]...]).\n",
    "    def forward(self, x):\n",
    "        x = F.relu(self.layer1(x))\n",
    "        x = F.relu(self.layer2(x))\n",
    "        return self.layer3(x)\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    Transition = namedtuple(\"Transition\", (\"state\", \"action\", \"next_state\", \"reward\"))\n",
    "\n",
    "    class ReplayMemory(object):\n",
    "        def __init__(self, capacity):\n",
    "            self.memory = deque([], maxlen=capacity)\n",
    "\n",
    "        def push(self, *args):\n",
    "            \"\"\"Save a transition\"\"\"\n",
    "            self.memory.append(Transition(*args))\n",
    "\n",
    "        def sample(self, batch_size):\n",
    "            return random.sample(self.memory, batch_size)\n",
    "\n",
    "        def __len__(self):\n",
    "            return len(self.memory)\n",
    "\n",
    "    BATCH_SIZE = 128\n",
    "    GAMMA = 0.99\n",
    "    EPS_START = 0.9\n",
    "    EPS_END = 0.05\n",
    "    EPS_DECAY = 1000\n",
    "    TAU = 0.005\n",
    "    LR = 1e-4\n",
    "\n",
    "    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "    env = gym.make(\"CartPole-v1\")\n",
    "\n",
    "    state, info = env.reset()\n",
    "    n_observations = len(state)\n",
    "    n_actions = env.action_space.n\n",
    "\n",
    "    policy_net = DQN(n_observations, n_actions).to(device)\n",
    "    target_net = DQN(n_observations, n_actions).to(device)\n",
    "    target_net.load_state_dict(policy_net.state_dict())\n",
    "\n",
    "    optimizer = optim.AdamW(policy_net.parameters(), lr=LR, amsgrad=True)\n",
    "    memory = ReplayMemory(10000)\n",
    "\n",
    "    steps_done = 0\n",
    "\n",
    "    def select_action(state):\n",
    "        global steps_done\n",
    "        sample = random.random()\n",
    "        eps_threshold = EPS_END + (EPS_START - EPS_END) * math.exp(\n",
    "            -1.0 * steps_done / EPS_DECAY\n",
    "        )\n",
    "        steps_done += 1\n",
    "        if sample > eps_threshold:\n",
    "            with torch.no_grad():\n",
    "                # t.max(1) will return the largest column value of each row.\n",
    "                # second column on max result is index of where max element was\n",
    "                # found, so we pick action with the larger expected reward.\n",
    "                return policy_net(state).max(1).indices.view(1, 1)\n",
    "        else:\n",
    "            return torch.tensor(\n",
    "                [[env.action_space.sample()]], device=device, dtype=torch.long\n",
    "            )\n",
    "\n",
    "    episode_durations = []\n",
    "\n",
    "    def plot_durations(show_result=False):\n",
    "        plt.figure(1)\n",
    "        durations_t = torch.tensor(episode_durations, dtype=torch.float)\n",
    "        if show_result:\n",
    "            plt.title(\"Result\")\n",
    "        else:\n",
    "            plt.clf()\n",
    "            plt.title(\"Training...\")\n",
    "        plt.xlabel(\"Episode\")\n",
    "        plt.ylabel(\"Duration\")\n",
    "        plt.plot(durations_t.numpy())\n",
    "        # Take 100 episode averages and plot them too\n",
    "        if len(durations_t) >= 100:\n",
    "            means = durations_t.unfold(0, 100, 1).mean(1).view(-1)\n",
    "            means = torch.cat((torch.zeros(99), means))\n",
    "            plt.plot(means.numpy())\n",
    "\n",
    "        plt.pause(0.001)  # pause a bit so that plots are updated\n",
    "        # if is_ipython:\n",
    "        #     if not show_result:\n",
    "        #         display.display(plt.gcf())\n",
    "        #         display.clear_output(wait=True)\n",
    "        #     else:\n",
    "        #         display.display(plt.gcf())\n",
    "        #\n",
    "\n",
    "    def optimize_model():\n",
    "        if len(memory) < BATCH_SIZE:\n",
    "            return\n",
    "        transitions = memory.sample(BATCH_SIZE)\n",
    "        # Transpose the batch (see https://stackoverflow.com/a/19343/3343043 for\n",
    "        # detailed explanation). This converts batch-array of Transitions\n",
    "        # to Transition of batch-arrays.\n",
    "        batch = Transition(*zip(*transitions))\n",
    "\n",
    "        # Compute a mask of non-final states and concatenate the batch elements\n",
    "        # (a final state would've been the one after which simulation ended)\n",
    "        non_final_mask = torch.tensor(\n",
    "            tuple(map(lambda s: s is not None, batch.next_state)),\n",
    "            device=device,\n",
    "            dtype=torch.bool,\n",
    "        )\n",
    "        non_final_next_states = torch.cat(\n",
    "            [s for s in batch.next_state if s is not None]\n",
    "        )\n",
    "        state_batch = torch.cat(batch.state)\n",
    "        action_batch = torch.cat(batch.action)\n",
    "        reward_batch = torch.cat(batch.reward)\n",
    "\n",
    "        # Compute Q(s_t, a) - the model computes Q(s_t), then we select the\n",
    "        # columns of actions taken. These are the actions which would've been taken\n",
    "        # for each batch state according to policy_net\n",
    "        state_action_values = policy_net(state_batch).gather(1, action_batch)\n",
    "\n",
    "        # Compute V(s_{t+1}) for all next states.\n",
    "        # Expected values of actions for non_final_next_states are computed based\n",
    "        # on the \"older\" target_net; selecting their best reward with max(1).values\n",
    "        # This is merged based on the mask, such that we'll have either the expected\n",
    "        # state value or 0 in case the state was final.\n",
    "        next_state_values = torch.zeros(BATCH_SIZE, device=device)\n",
    "        with torch.no_grad():\n",
    "            next_state_values[non_final_mask] = (\n",
    "                target_net(non_final_next_states).max(1).values\n",
    "            )\n",
    "        # Compute the expected Q values\n",
    "        expected_state_action_values = (next_state_values * GAMMA) + reward_batch\n",
    "\n",
    "        # Compute Huber loss\n",
    "        criterion = nn.SmoothL1Loss()\n",
    "        loss = criterion(state_action_values, expected_state_action_values.unsqueeze(1))\n",
    "\n",
    "        # Optimize the model\n",
    "        optimizer.zero_grad()\n",
    "        loss.backward()\n",
    "        # In-place gradient clipping\n",
    "        torch.nn.utils.clip_grad_value_(policy_net.parameters(), 100)\n",
    "        optimizer.step()\n",
    "\n",
    "    if torch.cuda.is_available():\n",
    "        num_episodes = 600\n",
    "    else:\n",
    "        num_episodes = 600\n",
    "\n",
    "    for i_episode in tqdm(range(num_episodes)):\n",
    "        # Initialize the environment and get its state\n",
    "        state, info = env.reset()\n",
    "        state = torch.tensor(state, dtype=torch.float32, device=device).unsqueeze(0)\n",
    "        for t in count():\n",
    "            action = select_action(state)\n",
    "            observation, reward, terminated, truncated, _ = env.step(action.item())\n",
    "            reward = torch.tensor([reward], device=device)\n",
    "            done = terminated or truncated\n",
    "\n",
    "            if terminated:\n",
    "                next_state = None\n",
    "            else:\n",
    "                next_state = torch.tensor(\n",
    "                    observation, dtype=torch.float32, device=device\n",
    "                ).unsqueeze(0)\n",
    "\n",
    "            # Store the transition in memory\n",
    "            memory.push(state, action, next_state, reward)\n",
    "\n",
    "            # Move to the next state\n",
    "            state = next_state\n",
    "\n",
    "            # Perform one step of the optimization (on the policy network)\n",
    "            optimize_model()\n",
    "\n",
    "            # Soft update of the target network's weights\n",
    "            # θ′ ← τ θ + (1 −τ )θ′\n",
    "            target_net_state_dict = target_net.state_dict()\n",
    "            policy_net_state_dict = policy_net.state_dict()\n",
    "            for key in policy_net_state_dict:\n",
    "                target_net_state_dict[key] = policy_net_state_dict[\n",
    "                    key\n",
    "                ] * TAU + target_net_state_dict[key] * (1 - TAU)\n",
    "            target_net.load_state_dict(target_net_state_dict)\n",
    "\n",
    "            if done:\n",
    "                episode_durations.append(t + 1)\n",
    "                # plot_durations()\n",
    "                break\n",
    "\n",
    "    print(\"Complete\")\n",
    "    plot_durations(show_result=True)\n",
    "    plt.show()\n",
    "\n",
    "    torch.save(target_net.state_dict(), \"policy_net.pt\")\n",
    "    end_time = time.time()  # End time\n",
    "print(f\"Execution time: {end_time - start_time} seconds\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "84bf0e61-e23d-4efb-9836-b26b0db3291b",
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[3], line 25\u001b[0m\n\u001b[0;32m     23\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m time_i \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mrange\u001b[39m(\u001b[38;5;241m500\u001b[39m):\n\u001b[0;32m     24\u001b[0m     action \u001b[38;5;241m=\u001b[39m policy_net(torch\u001b[38;5;241m.\u001b[39mFloatTensor(state, device\u001b[38;5;241m=\u001b[39mdevice))\u001b[38;5;241m.\u001b[39margmax()\u001b[38;5;241m.\u001b[39mitem()\n\u001b[1;32m---> 25\u001b[0m     state, reward, terminated, truncated, info \u001b[38;5;241m=\u001b[39m \u001b[43menv\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mstep\u001b[49m\u001b[43m(\u001b[49m\u001b[43maction\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     26\u001b[0m     time\u001b[38;5;241m.\u001b[39msleep(\u001b[38;5;241m0.01\u001b[39m)\n\u001b[0;32m     28\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m terminated:\n",
      "File \u001b[1;32m~\\anaconda3\\lib\\site-packages\\gymnasium\\wrappers\\time_limit.py:57\u001b[0m, in \u001b[0;36mTimeLimit.step\u001b[1;34m(self, action)\u001b[0m\n\u001b[0;32m     46\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mstep\u001b[39m(\u001b[38;5;28mself\u001b[39m, action):\n\u001b[0;32m     47\u001b[0m     \u001b[38;5;124;03m\"\"\"Steps through the environment and if the number of steps elapsed exceeds ``max_episode_steps`` then truncate.\u001b[39;00m\n\u001b[0;32m     48\u001b[0m \n\u001b[0;32m     49\u001b[0m \u001b[38;5;124;03m    Args:\u001b[39;00m\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m     55\u001b[0m \n\u001b[0;32m     56\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n\u001b[1;32m---> 57\u001b[0m     observation, reward, terminated, truncated, info \u001b[38;5;241m=\u001b[39m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43menv\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mstep\u001b[49m\u001b[43m(\u001b[49m\u001b[43maction\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     58\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_elapsed_steps \u001b[38;5;241m+\u001b[39m\u001b[38;5;241m=\u001b[39m \u001b[38;5;241m1\u001b[39m\n\u001b[0;32m     60\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_elapsed_steps \u001b[38;5;241m>\u001b[39m\u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_max_episode_steps:\n",
      "File \u001b[1;32m~\\anaconda3\\lib\\site-packages\\gymnasium\\wrappers\\order_enforcing.py:56\u001b[0m, in \u001b[0;36mOrderEnforcing.step\u001b[1;34m(self, action)\u001b[0m\n\u001b[0;32m     54\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_has_reset:\n\u001b[0;32m     55\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m ResetNeeded(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mCannot call env.step() before calling env.reset()\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[1;32m---> 56\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43menv\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mstep\u001b[49m\u001b[43m(\u001b[49m\u001b[43maction\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[1;32m~\\anaconda3\\lib\\site-packages\\gymnasium\\wrappers\\env_checker.py:51\u001b[0m, in \u001b[0;36mPassiveEnvChecker.step\u001b[1;34m(self, action)\u001b[0m\n\u001b[0;32m     49\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m env_step_passive_checker(\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39menv, action)\n\u001b[0;32m     50\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m---> 51\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43menv\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mstep\u001b[49m\u001b[43m(\u001b[49m\u001b[43maction\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[1;32m~\\anaconda3\\lib\\site-packages\\gymnasium\\envs\\classic_control\\cartpole.py:190\u001b[0m, in \u001b[0;36mCartPoleEnv.step\u001b[1;34m(self, action)\u001b[0m\n\u001b[0;32m    187\u001b[0m     reward \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m0.0\u001b[39m\n\u001b[0;32m    189\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mrender_mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mhuman\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n\u001b[1;32m--> 190\u001b[0m     \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mrender\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m    191\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m np\u001b[38;5;241m.\u001b[39marray(\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mstate, dtype\u001b[38;5;241m=\u001b[39mnp\u001b[38;5;241m.\u001b[39mfloat32), reward, terminated, \u001b[38;5;28;01mFalse\u001b[39;00m, {}\n",
      "File \u001b[1;32m~\\anaconda3\\lib\\site-packages\\gymnasium\\envs\\classic_control\\cartpole.py:302\u001b[0m, in \u001b[0;36mCartPoleEnv.render\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    300\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mrender_mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mhuman\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n\u001b[0;32m    301\u001b[0m     pygame\u001b[38;5;241m.\u001b[39mevent\u001b[38;5;241m.\u001b[39mpump()\n\u001b[1;32m--> 302\u001b[0m     \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mclock\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mtick\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mmetadata\u001b[49m\u001b[43m[\u001b[49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mrender_fps\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m    303\u001b[0m     pygame\u001b[38;5;241m.\u001b[39mdisplay\u001b[38;5;241m.\u001b[39mflip()\n\u001b[0;32m    305\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mrender_mode \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mrgb_array\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "import time\n",
    "\n",
    "import gymnasium as gym\n",
    "import torch\n",
    "\n",
    "#from project.main import DQN\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "\n",
    "    env = gym.make(\"CartPole-v1\", render_mode=\"human\")\n",
    "    state, info = env.reset()\n",
    "    n_observations = len(state)\n",
    "    n_actions = env.action_space.n\n",
    "\n",
    "    policy_net = DQN(n_observations, n_actions).to(device)\n",
    "    policy_net.load_state_dict(torch.load(\"policy_net.pt\", map_location=device))\n",
    "\n",
    "    for episode_i in range(10):\n",
    "        state, info = env.reset()\n",
    "        env.render()\n",
    "\n",
    "        for time_i in range(500):\n",
    "            action = policy_net(torch.FloatTensor(state, device=device)).argmax().item()\n",
    "            state, reward, terminated, truncated, info = env.step(action)\n",
    "            time.sleep(0.01)\n",
    "\n",
    "            if terminated:\n",
    "                time.sleep(0.5)\n",
    "                break\n",
    "\n",
    "    env.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "21ce42ae-68e4-487c-9b36-cd47fc58b0fb",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Generation: 100%|██████████| 50/50 [00:06<00:00,  7.84it/s]\n",
      "C:\\Users\\16144\\anaconda3\\lib\\site-packages\\gym\\envs\\classic_control\\cartpole.py:211: UserWarning: \u001b[33mWARN: You are calling render method without specifying any render mode. You can specify the render_mode at initialization, e.g. gym(\"CartPole-v1\", render_mode=\"rgb_array\")\u001b[0m\n",
      "  gym.logger.warn(\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best policy rules: [-0.06784741  0.30853465  0.11295829  0.85950907]\n",
      "Episode 1 finished after 500 timesteps with reward 500.0.\n",
      "Episode 2 finished after 500 timesteps with reward 500.0.\n",
      "Episode 3 finished after 500 timesteps with reward 500.0.\n",
      "Episode 4 finished after 500 timesteps with reward 500.0.\n",
      "Episode 5 finished after 500 timesteps with reward 500.0.\n",
      "Execution time: 6.521459102630615 seconds\n"
     ]
    }
   ],
   "source": [
    "#GA implementation\n",
    "import gym\n",
    "import numpy as np\n",
    "from tqdm import tqdm\n",
    "import time \n",
    "start_time = time.time()  # Start time\n",
    "\n",
    "class Policy:\n",
    "    def __init__(self, rules=None):\n",
    "        self.rules = rules if rules is not None else np.random.rand(4) * 2 - 1\n",
    "\n",
    "    def decide_action(self, observation):\n",
    "        return 0 if np.dot(self.rules, observation) < 0 else 1\n",
    "    \n",
    "    def mutate(self, mutation_rate=0.1):\n",
    "        mutation = (np.random.rand(4) * 2 - 1) * mutation_rate\n",
    "        self.rules += mutation\n",
    "def calculate_fitness(policy, env):\n",
    "    reset_return = env.reset()\n",
    "    # Check if the environment's reset method returns a tuple and extract the observation\n",
    "    if isinstance(reset_return, tuple):\n",
    "        observation = reset_return[0]  # Assuming the observation is the first element\n",
    "    else:\n",
    "        observation = reset_return  # Direct assignment if not a tuple\n",
    "\n",
    "    total_reward = 0\n",
    "    for _ in range(1000):\n",
    "        action = policy.decide_action(observation)\n",
    "        step_return = env.step(action)\n",
    "        if isinstance(step_return, tuple) and len(step_return) == 5:\n",
    "            observation, reward, done, truncated, _ = step_return  # Adjusted for environments returning a tuple with 5 elements\n",
    "        elif isinstance(step_return, tuple) and len(step_return) == 4:\n",
    "            observation, reward, done, _ = step_return  # Standard Gym environment return\n",
    "        else:\n",
    "            observation = step_return  # Direct assignment if not a tuple, uncommon case\n",
    "\n",
    "        total_reward += reward\n",
    "        if done or truncated:  # Added 'truncated' to handle environments where an episode can be truncated\n",
    "            break\n",
    "    return total_reward\n",
    "\n",
    "def genetic_algorithm(env, generations=50, population_size=10):\n",
    "    population = [Policy() for _ in range(population_size)]\n",
    "    fitness_scores = []  # Initialize fitness_scores outside the loop\n",
    "    \n",
    "    for _ in tqdm(range(generations), desc=\"Generation\"):\n",
    "        fitness_scores = [calculate_fitness(policy, env) for policy in population]\n",
    "        \n",
    "        sorted_population = sorted(zip(fitness_scores, population), key=lambda x: x[0], reverse=True)\n",
    "        survivors = [policy for _, policy in sorted_population[:population_size // 2]]\n",
    "        \n",
    "        children = []\n",
    "        while len(children) < population_size - len(survivors):\n",
    "            parent1, parent2 = np.random.choice(survivors, 2, replace=False)\n",
    "            child1_rules = (parent1.rules + parent2.rules) / 2\n",
    "            child1 = Policy(child1_rules)\n",
    "            child1.mutate()\n",
    "            children.append(child1)\n",
    "        \n",
    "        population = survivors + children\n",
    "\n",
    "    if population and fitness_scores:\n",
    "        best_fitness = max(fitness_scores)\n",
    "        best_policy_index = fitness_scores.index(best_fitness)\n",
    "        return population[best_policy_index]\n",
    "    else:\n",
    "        return Policy()\n",
    "\n",
    "def play_cartpole_with_policy(env, policy, episodes=5):\n",
    "    for episode in range(episodes):\n",
    "        reset_return = env.reset()\n",
    "        # Check if the environment's reset method returns a tuple and extract the observation\n",
    "        if isinstance(reset_return, tuple):\n",
    "            observation = reset_return[0]  # Assuming the observation is the first element\n",
    "        else:\n",
    "            observation = reset_return  # Direct assignment if not a tuple\n",
    "        \n",
    "        total_reward = 0\n",
    "        for t in range(1000):\n",
    "            env.render()\n",
    "            action = policy.decide_action(observation)\n",
    "            step_return = env.step(action)\n",
    "            if isinstance(step_return, tuple) and len(step_return) == 5:\n",
    "                observation, reward, done, truncated, _ = step_return  # Adjusted for environments returning a tuple with 5 elements\n",
    "            elif isinstance(step_return, tuple) and len(step_return) == 4:\n",
    "                observation, reward, done, _ = step_return  # Standard Gym environment return\n",
    "            else:\n",
    "                observation = step_return  # Direct assignment if not a tuple, uncommon case\n",
    "\n",
    "            total_reward += reward\n",
    "            if done or truncated:  # Added 'truncated' to handle environments where an episode can be truncated\n",
    "                print(f\"Episode {episode+1} finished after {t+1} timesteps with reward {total_reward}.\")\n",
    "                break\n",
    "    env.close()\n",
    "\n",
    "# Initialize the environment and run the genetic algorithm\n",
    "env = gym.make(\"CartPole-v1\")\n",
    "best_policy = genetic_algorithm(env)\n",
    "if best_policy:\n",
    "    print(\"Best policy rules:\", best_policy.rules)\n",
    "    play_cartpole_with_policy(env, best_policy)\n",
    "else:\n",
    "    print(\"Failed to evolve a policy.\")\n",
    "end_time = time.time()  # End time\n",
    "print(f\"Execution time: {end_time - start_time} seconds\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "90c8dc4a-5176-4354-aa7d-712e9a048fca",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Cartpole playing using GA\n",
    "import time\n",
    "import gymnasium as gym\n",
    "import numpy as np\n",
    "\n",
    "class Policy:\n",
    "    def __init__(self, rules=None):\n",
    "        # Ensure rules are a numpy array for dot product operation\n",
    "        self.rules = np.array(rules if rules is not None else np.random.rand(4) * 2 - 1)\n",
    "\n",
    "    def decide_action(self, observation):\n",
    "        # Convert observation to numpy array to ensure dot product works correctly\n",
    "        observation = np.array(observation)\n",
    "        return 0 if np.dot(self.rules, observation) < 0 else 1\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    env = gym.make(\"CartPole-v1\", render_mode=\"human\")\n",
    "\n",
    "    best_policy = Policy()  # This should be replaced with your actual best policy from GA\n",
    "    \n",
    "    for episode_i in range(100):\n",
    "        observation, info = env.reset()  # Use env.reset() correctly based on gymnasium API\n",
    "\n",
    "        for time_i in range(5000):\n",
    "            env.render()  # Render the environment at the current state\n",
    "            action = best_policy.decide_action(observation)  # Get action from the policy\n",
    "            observation, reward, done, truncated, info = env.step(action)  # Execute the action\n",
    "\n",
    "            time.sleep(0.01)  # Sleep to slow down the loop for visual inspection\n",
    "            if done or truncated:  # Break the loop if the episode is over\n",
    "                break\n",
    "\n",
    "    env.close()  # Close the environment after all episodes are done\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
